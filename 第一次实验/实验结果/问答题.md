# OSLAB1问答题

1. 什么是复杂指令集？什么是精简指令集？80x86采⽤的是哪种？

   复杂指令集：CISC，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。

   精简指令集：RISC，是一种执行较少类型计算机指令的微处理器

   8086采用复杂指令集。

2. 什么是⼩端存储？什么是⼤端存储？80x86采⽤的是哪种？

   1. 小端：数据的高字节存在高地址；大端：数据的高字节存在内存的低地址
   2. 8086采用的是**小端存储**

3. 8086有哪5类寄存器？请分别举例说明其作⽤。

   1. **数据寄存器**(AX, BX, CX, DX)：

      AX――累加器（Accumulator），使用频度最高
      BX――基址寄存器（Base Register），常存放存储器地址
      CX――计数器（Count Register），常作为计数器
      DX――数据寄存器（Data Register），存放数据

   2. **指针寄存器**(BP, SP)：BP是指针寄存器，通常BP寄存器在间接寻址中使用，操作数在堆栈段中，由SS段寄存器和BP组合形成操作数的地址，即BP中存放现行堆栈段中一个数据区的“基址”的偏移量，所以称BP为基址指针。

   3. **变址寄存器**(SI, DI)：SI是源变址寄存器，用来存放相对于DS段之源变址指针

   4. **控制寄存器**(IP, FLAG)：FLAG是标志寄存器，用来存储相关指令的某些执行结果，为CPU执行相关指令提供行为依据（ZF， CF之类的）

   5. **段寄存器**(CS, DS, SS, ES)：DS用来存储要访问数据的段地址

4. 有哪些段寄存器，它们的作⽤是什么？

   CS是[代码段](https://baike.baidu.com/item/代码段/9966451?fromModule=lemma_inlink)，DS是[数据段](https://baike.baidu.com/item/数据段/5136260?fromModule=lemma_inlink)，SS是[堆栈段](https://baike.baidu.com/item/堆栈段/1374659?fromModule=lemma_inlink)，ES是附加段。

   把内存分段后，每一个段就有一个段基址，段寄存器保存的就是这个段基址的**高16位**，这个16位的地址左移四位（后面加上4个0）就可构成20位的段基址。

5. 什么是寻址？8086有哪些寻址⽅式？

   找到操作数的地址(从而能够取出操作数)

   8086有七种基本的寻址方式：立即寻址，直接寻址，寄存器寻址，寄存器间接寻址，寄存器相对寻址，基址加变址，相对基址加变址。

6. 什么是直接寻址？直接寻址的缺点是什么？

   直接寻址给出了操作数的地址，用[]取数

   位数决定了该指令操作数的寻址范围，操作数的地址不易修改

7. 主程序与⼦程序之间如何传递参数？你的实验代码中在哪⾥体现的？

   用寄存器传递、用堆栈传递（常用）和用存储器传递

   1. 将子程序的输入参数由主程序放入规定的[寄存器](https://so.csdn.net/so/search?q=寄存器&spm=1001.2101.3001.7020)带入子程序中。执行子程序后的结果也放入规定的寄存器带回主程序
   2. 用PUSH指令将输入参数压入堆栈，在子程序中通过POP出栈依次获得这些参数。经过子程序操作处理后再将输出参数压入堆栈，返回主程序后再通过出栈获得结果。
   3. 使用一个存储区（约定的地址）来保存和传递主、子程序间的参数

8. 如何处理输⼊和输出？你的代码中在哪⾥体现的？

   通过系统调用，64bit系统设置好参数后使用syscall，32bit好像要通过中断指令

9. 通过什么寄存器保存前⼀次的运算结果？你的代码中在哪⾥体现的？

   数据寄存器，代码中使用rax

10. 请分别简述 MOV 指令和 LEA 指令的⽤法和作⽤。

    `mov` 指令用于Load value。通俗的说，如果源操作数是常量，有没有[ ]括号都代表常量。如果源操作数是寄存器，有[ ]表示取地址（eax存的地址指向的值）操作，无[ ]表示取值操作。

    `lea` 指令(Load Effective Address)只能用于 **memory addressing calculations**， 不能用于 **address memory** 的计算。同时，lea指令不会修改flags。

    使用[]时：

    `mov` 读取在内存地址[]位置的数据

    `lea` 计算一个表达式[]结果

11. 解释 boot.asm ⽂件中 org 0700h 的作⽤。

    告诉编译器程序加载到0700h处，没有的话默认加载到0h处，这样会导致出错

12. 解释 boot.asm ⽂件中 times 510-($-$$) db 0 的作⽤。

    `$` 表示程序当前位置的地址，也就是0x7c09

    `$$` 表示程序被编译后的开始地址，也就是0x7c00

    作用：表示在这个程序后填充0，直到达到510字节，然后加上结束标志位0xaa55正好是512字节，填满一个扇区

13. 解释 bochsrc 中各参数的含义。

    - megs：虚拟机内存⼤⼩ (MB)
    - display_library: Bochs使⽤的GUI库
    - floppya: 虚拟机外设，软盘为a.img⽂件
    - boot: 虚拟机启动⽅式，从软盘启动

14. boot.bin 应该放在软盘的哪⼀个扇区？为什么？

    第一个扇区

    原因：BIOS程序检查软盘0面0磁道1扇区，如果扇区以0xaa55结束，则认定为引导扇区，将其512字节的数据加载到内存的07c00处，然后设置PC，跳到内存07c00处开始执行代码。这是程序约定的做法。

15. Loader的作⽤有哪些？

    1. 跳⼊保护模式
    2. 启动内存分⻚
    3. 从kernel.bin中读取内核，并放⼊内存，然后跳转到内核所在的开始地址，运⾏内核
